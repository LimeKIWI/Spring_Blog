# 나만의 블로그


[배포사이트 : http://3.39.195.61/](http://3.39.195.61/)

***

### 1. api 설계

* 요구사항 

> -  회원 가입 API
    - 닉네임, 비밀번호, 비밀번호 확인을 request에서 전달받기
    - 닉네임은 `최소 4자 이상, 12자 이하 알파벳 대소문자(a~z, A~Z), 숫자(0~9)`로 구성하기
    - 비밀번호는 `최소 4자 이상이며, 32자 이하 알파벳 소문자(a~z), 숫자(0~9)` 로 구성하기
    - 비밀번호 확인은 비밀번호와 정확하게 일치하기
- 로그인 API
    - 닉네임, 비밀번호를 request에서 전달받기
    - 로그인 버튼을 누른 경우 닉네임과 비밀번호가 데이터베이스에 등록됐는지 확인하기
    - 로그인 성공 시, JWT를 활용하여 AccessToken을 발급하고, 
    발급한 AccessToken은 Header의 Access-Token에 담아서 반환하기
    - 로그인 성공 시, JWT를 활용하여 RefreshToken을 발급하고,
    발급한 RefreshToken은 Header의 Refresh-Token에 담아서 반환하기
 - 전체 게시글 목록 조회 API (전체 글 목록)
    - 제목, 작성자명, 작성 날짜를 조회하기
    - 작성 날짜 기준으로 내림차순 정렬하기    
- 게시글 작성 API (글쓰기)
    - Token이 있고, 유효한 Token일 때만 제목, 작성 내용을 입력하기    
- 게시글 조회 API (게시글 상세보기)
    - 제목, 작성자명, 작성 날짜, 작성 내용을 조회하기      
- 게시글 수정 API (수정하기)
    - Token이 있고, 유효한 Token이면서 해당 사용자가 작성한 글만 제목, 작성 내용을 수정되게 하기   
- 게시글 삭제 API (삭제하기)
    - Token이 있고, 유효한 Token이면서 해당 사용자가 작성한 글만 글이 삭제되게 하기
 - 댓글 목록 조회 API
    - Token이 없어도 댓글 목록 조회가 가능하도록 하기
    - 조회하는 게시글에 작성된 모든 댓글을 response에 포함하기
- 댓글 작성 API
    - Token이 있고, 유효한 Token일 때만 댓글 작성이 가능하도록 하기
- 댓글 수정 API
    - Token이 있고, 유효한 Token이면서 해당 사용자가 작성한 댓글만 수정 가능하도록 하기
- 댓글 삭제 API
    - Token이 있고, 유효한 Token이면서 해당  사용자가 작성한 댓글만 삭제 가능하도록 하기
- 모든 인증필요한 기능은 acess토큰과 refresh토큰이 있을때에만 정상 response를 주기

***    

### 2. api 명세서


|description|method|uri|request|response|
|:---:|:---:|:---:|:---:|:---:|
|로그인|POST|/api/member/login|{"nickName":"닉네임", "password":"비밀번호"}|닉네임님 로그인성공|
|회원가입|POST|/api/member/signup|{"nickName":"닉네임", "password":"비밀번호", "passwordConfirm" : "비밀번호"}|닉네임님 회원가입완료|
|전체조회|GET|/api/posts|-|[ {"id": 2, "title": "제목2", "author": "작성자2", "createAt": "2022-08-16T00:10:00", "modifiedAt": "2022-08-16T00:10:00" }, {"id": 1, "title": "제목1", "author": "작성자1", "createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:00" } ]
|글작성|POST|/api/auth/posts|{ "title": "제목1", "content": "내용1"}|{"id": 1, "title": "제목1", "author": "작성자1", "content": "내용1", "createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20" }|
|글조회|GET|/api/posts/{id}|-|{"id": 1, "title": "제목1", "author": "작성자1", "content": "내용1", "createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20" }|{"id": 1, "title": "제목1", "author": "작성자1", "content": "내용1", "createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20" }|
|글수정|POST|/api/auth/posts/{id}|{ "title": "제목1", "content": "내용1"}|{"id": 1, "title": "제목1", "author": "작성자1", "content": "내용1", "createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20" }|
|글삭제|DELETE|/api/auth/posts/{id}|-|1번글 삭제|
|댓글조회|GET|/api/comment/{id}|-|{"id": 1,"author": "작성자1","content": "내용","createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20"}, {"id": 2,"author": "작성자2","content": "내용2","createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20"}|
|댓글쓰기|POST|/api/auth/comment/|{"postId": 1, "content": "내용"}| {"id": 1,"author": "작성자1","content": "내용","createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20"}|
|댓글수정|PUT|/api/auth/comment/{id}|{"postId": 1, "content": "수정내용"}|{"id": 1,"author": "작성자1","content": "수정내용","createAt": "2022-08-16T00:00:00", "modifiedAt": "2022-08-16T00:00:20"}|
|댓글삭제|DELETE|/api/auth/comment/{id}|-|1번댓글 삭제|


***    

### 3. trouble shooting

>- h2첫 db접속시에 db파일이 자동생성이 되지 않아서 직접 db파일을 해당경로에 생성해서 오류를 해결하였음. 이때 직접만들어낸 db에는 bigInt타입으로 컬럼데이터타입을 선언할때 크기를 함께 선언하면 구문오류가 발생하던것을 확인함.
- 서버에서 배포를 위해 jar파일을 실행시킬때 오류가 발생함. 오류내용을 읽어보니 자바의 버전이 낮아서 컴파일러 버전차이로 오류가 발생한 것임. 작성된 코드가 java11기반이고 강의에서 제공된 자바버전은 8이라 자료를 확인하고 jdk 설치 구문에서 8을 11로만 수정하여 sudo apt-get install openjdk-11-jdk로 11버전을 설치해서 해결함.
- 객체가 생성될 때 제목, 작성자명 이외에도 비밀번호가 객체에 저장되게 되는데 객체 자체를 응답으로 반환한다면 비밀번호같은 민감정보가 클라이언트로 그대로 노출됨. 이것을 막기위해 테이블을 글정보와 비밀번호 테이블 두개를 작성하여 사용해보았지만 확장성이나 효율성이 좋지않고 코드도 복잡해져서 삭제 후 응답을 위한 dto객체를 생성하여 필요정보만을 가진 dto를 응답으로 반환하게 재설계함. 
- 테이블 구조 변경이후 local에서 Mysql db를 ec2서버와 함께 사용하여 db무결성이 깨져서 db가 꼬이는 일이 발생함
데이터베이스를 초기화하여 해결함. db구조가 바뀐다면 기존 db와 연동하지 않고 h2를 이용하여 테스트를 해야함.
- 스프링부트 2.7버전부터 시큐리티 어뎁터를 사용할 수 없어서 직접 구글링을하여 버전 다운하는 법을 알아냈음 기존 자료가 훨씬 많고 아직 현역에서도 쓰고있는 이전버전의 스프링시큐리티를 사용하는 것이 더 유리해 보였음.
- 게시글이 삭제될때 댓글도 함께 삭제하게 하기 위해 cascade의 remove를 사용하려 해보았으나 데이터베이스에 중복자료들이 저장될 위험성이 있어서 제외하고 각 포스트의 id를 저장해서 commentrepository를 활용해 postid값만으로 검색을한뒤 그 코멘트를 삭제하게함.

